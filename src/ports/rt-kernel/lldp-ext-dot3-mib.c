/*
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

p-net Profinet device stack
===========================

Copyright 2018 rt-labs AB

This instance of p-net is licensed for use in a specific product, as
follows:

Company: Bender GmbH & Co. KG
Product: COMTRAXX
Product description: COMTRAXX products provided by Bender GmbH & Co. KG

Use of this instance of p-net in other products is not allowed.

You are hereby given a non-exclusive, non-transferable license to use
the SOFTWARE and documentation according to the SOFTWARE LICENSE
AGREEMENT document shipped together with this instance of the
SOFTWARE. The SOFTWARE LICENSE AGREEMENT prohibits copying and
redistribution of the SOFTWARE.  It prohibits reverse-engineering
activities.  It limits warranty and liability on behalf of rt-labs.
The details of these terms are explained in subsequent chapters of the
SOFTWARE LICENSE AGREEMENT.
-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEE1e4U+gPgGJXLsxxLZlG0bopmiXIFAl/TMvQACgkQZlG0bopm
iXJE1QgAlEKblKkIrLF+hVRm6I1IfbGV6VWnBx+9IPwaHZmgQZAVTOlp4RHiNAre
Il1l1xheENWpuihbVlvz5hMCVto4fkT13IUXxOo9Va9MK8lm6JOu2lYpl1HgVIwV
R6I6dsWLeNBSBaA38DDBHIfjP4LBZC/HVYO2ISc3/OKutqasz/WIp+AjAURiKRsf
yaWGay88FITHymmqJpGaWzB+jAOvRFs8hW/GsOyX/r17AK5F5N51O+UqUTKAWNPT
f6M8QF0b07Hw+eOuB7A/0D5nvSl/rOd9LvYkiUhIUmQdHqERNkF9EJdroIjxTMXi
lmoOkPEqyGV58fh7JjMYlI60sPlGBw==
=TaN+
-----END PGP SIGNATURE-----
*/

#include "lldp-ext-dot3-mib.h"

#include "options.h"
#include "pnet_api.h"
#include "osal.h"
#include "osal_log.h"
#include "pnal.h"
#include "pf_types.h"
#include "pf_snmp.h"
#include "pnal_snmp.h"
#include "rowindex.h"

#include <string.h>

/*
Generated by LwipMibCompiler
*/

#include "lwip/apps/snmp_opts.h"
#if LWIP_SNMP

#include "lldp-ext-dot3-mib.h"
#include "lwip/apps/snmp.h"
#include "lwip/apps/snmp_core.h"
#include "lwip/apps/snmp_scalar.h"
#include "lwip/apps/snmp_table.h"

/* --- lldpXdot3LocalData 1.0.8802.1.1.2.1.5.4623.1.2
 * ----------------------------------------------------- */
static snmp_err_t lldpxdot3locporttable_get_instance (
   const u32_t * column,
   const u32_t * row_oid,
   u8_t row_oid_len,
   struct snmp_node_instance * cell_instance);
static snmp_err_t lldpxdot3locporttable_get_next_instance (
   const u32_t * column,
   struct snmp_obj_id * row_oid,
   struct snmp_node_instance * cell_instance);
static s16_t lldpxdot3locporttable_get_value (
   struct snmp_node_instance * cell_instance,
   void * value);
static const struct snmp_table_col_def lldpxdot3locporttable_columns[] = {
   {1,
    SNMP_ASN1_TYPE_INTEGER,
    SNMP_NODE_INSTANCE_READ_ONLY}, /* lldpXdot3LocPortAutoNegSupported
                                    */
   {2,
    SNMP_ASN1_TYPE_INTEGER,
    SNMP_NODE_INSTANCE_READ_ONLY}, /* lldpXdot3LocPortAutoNegEnabled
                                    */
   {3,
    SNMP_ASN1_TYPE_OCTET_STRING,
    SNMP_NODE_INSTANCE_READ_ONLY}, /* lldpXdot3LocPortAutoNegAdvertisedCap
                                    */
   {4,
    SNMP_ASN1_TYPE_INTEGER,
    SNMP_NODE_INSTANCE_READ_ONLY}, /* lldpXdot3LocPortOperMauType
                                    */
};
static const struct snmp_table_node lldpxdot3locporttable = SNMP_TABLE_CREATE (
   1,
   lldpxdot3locporttable_columns,
   lldpxdot3locporttable_get_instance,
   lldpxdot3locporttable_get_next_instance,
   lldpxdot3locporttable_get_value,
   NULL,
   NULL);

static const struct snmp_node * const lldpxdot3localdata_subnodes[] = {
   &lldpxdot3locporttable.node.node,
};
static const struct snmp_tree_node lldpxdot3localdata_treenode =
   SNMP_CREATE_TREE_NODE (2, lldpxdot3localdata_subnodes);

/* --- lldpXdot3RemoteData 1.0.8802.1.1.2.1.5.4623.1.3
 * ----------------------------------------------------- */
static snmp_err_t lldpxdot3remporttable_get_instance (
   const u32_t * column,
   const u32_t * row_oid,
   u8_t row_oid_len,
   struct snmp_node_instance * cell_instance);
static snmp_err_t lldpxdot3remporttable_get_next_instance (
   const u32_t * column,
   struct snmp_obj_id * row_oid,
   struct snmp_node_instance * cell_instance);
static s16_t lldpxdot3remporttable_get_value (
   struct snmp_node_instance * cell_instance,
   void * value);
static const struct snmp_table_col_def lldpxdot3remporttable_columns[] = {
   {1,
    SNMP_ASN1_TYPE_INTEGER,
    SNMP_NODE_INSTANCE_READ_ONLY}, /* lldpXdot3RemPortAutoNegSupported
                                    */
   {2,
    SNMP_ASN1_TYPE_INTEGER,
    SNMP_NODE_INSTANCE_READ_ONLY}, /* lldpXdot3RemPortAutoNegEnabled
                                    */
   {3,
    SNMP_ASN1_TYPE_OCTET_STRING,
    SNMP_NODE_INSTANCE_READ_ONLY}, /* lldpXdot3RemPortAutoNegAdvertisedCap
                                    */
   {4,
    SNMP_ASN1_TYPE_INTEGER,
    SNMP_NODE_INSTANCE_READ_ONLY}, /* lldpXdot3RemPortOperMauType
                                    */
};
static const struct snmp_table_node lldpxdot3remporttable = SNMP_TABLE_CREATE (
   1,
   lldpxdot3remporttable_columns,
   lldpxdot3remporttable_get_instance,
   lldpxdot3remporttable_get_next_instance,
   lldpxdot3remporttable_get_value,
   NULL,
   NULL);

static const struct snmp_node * const lldpxdot3remotedata_subnodes[] = {
   &lldpxdot3remporttable.node.node,
};
static const struct snmp_tree_node lldpxdot3remotedata_treenode =
   SNMP_CREATE_TREE_NODE (3, lldpxdot3remotedata_subnodes);

/* --- lldpXdot3Objects 1.0.8802.1.1.2.1.5.4623.1
 * ----------------------------------------------------- */
static const struct snmp_node * const lldpxdot3objects_subnodes[] = {
   &lldpxdot3localdata_treenode.node,
   &lldpxdot3remotedata_treenode.node};
static const struct snmp_tree_node lldpxdot3objects_treenode =
   SNMP_CREATE_TREE_NODE (1, lldpxdot3objects_subnodes);

/* --- lldpXdot3MIB  ----------------------------------------------------- */
static const struct snmp_node * const lldpxdot3mib_subnodes[] = {
   &lldpxdot3objects_treenode.node};
static const struct snmp_tree_node lldpxdot3mib_root =
   SNMP_CREATE_TREE_NODE (4623, lldpxdot3mib_subnodes);
static const u32_t lldpxdot3mib_base_oid[] = {1, 0, 8802, 1, 1, 2, 1, 5, 4623};
const struct snmp_mib lldpxdot3mib = {
   lldpxdot3mib_base_oid,
   LWIP_ARRAYSIZE (lldpxdot3mib_base_oid),
   &lldpxdot3mib_root.node};

/*
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LWIP MIB generator - preserved section begin
Code below is preserved on regeneration. Remove these comment lines to
regenerate code.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/

/* --- lldpXdot3LocalData 1.0.8802.1.1.2.1.5.4623.1.2
 * ----------------------------------------------------- */

/**
 * Get cell in table lldpXdot3LocPortTable.
 *
 * Called when an SNMP Get request is received for this table.
 * If cell is found, the SNMP stack may call the corresponding get_value()
 * function below to retrieve the actual value contained in the cell.
 *
 * @param column           In:    Column index for the cell.
 * @param row_oid          In:    Row index (array) for the cell.
 * @param row_oid_len      In:    The number of elements in the row index array.
 * @param cell_instance    InOut: Cell instance (containing meta-data).
 * @return  SNMP_ERR_NOERROR if cell was found,
 *          SNMP_ERR_NOSUCHINSTANCE otherwise.
 */
static snmp_err_t lldpxdot3locporttable_get_instance (
   const u32_t * column,
   const u32_t * row_oid,
   u8_t row_oid_len,
   struct snmp_node_instance * cell_instance)
{
   int port = rowindex_match_with_local_port (row_oid, row_oid_len);
   if (port == 0)
   {
      return SNMP_ERR_NOSUCHINSTANCE;
   }
   else
   {
      cell_instance->reference.s32 = port;
      return SNMP_ERR_NOERROR;
   }
}

/**
 * Get next cell in table lldpXdot3LocPortTable.
 *
 * Called when an SNMP GetNext request is received for this table.
 * If cell is found, the SNMP stack may call the corresponding get_value()
 * function below to retrieve the actual value contained in the cell.
 *
 * @param column           In:    Column index for the cell.
 * @param row_oid          InOut: Row index for the cell.
 * @param cell_instance    InOut: Cell instance (containing meta-data).
 * @return  SNMP_ERR_NOERROR if cell was found,
 *          SNMP_ERR_NOSUCHINSTANCE otherwise.
 */
static snmp_err_t lldpxdot3locporttable_get_next_instance (
   const u32_t * column,
   struct snmp_obj_id * row_oid,
   struct snmp_node_instance * cell_instance)
{
   int port = rowindex_update_with_next_local_port (row_oid);
   if (port == 0)
   {
      return SNMP_ERR_NOSUCHINSTANCE;
   }
   else
   {
      cell_instance->reference.s32 = port;
      return SNMP_ERR_NOERROR;
   }
}

/**
 * Get value at cell in table lldpXdot3LocPortTable.
 *
 * Called when an SNMP Get or GetNext request is received for this table.
 * The cell was previously identified in a call to get_instance() or
 * get_next_instance().
 *
 * @param cell_instance    In:    Cell instance (containing meta-data).
 * @param value            Out:   Value to be returned in response.
 * @return  Size of returned value, in bytes.
 *          0 if error occurred.
 */
static s16_t lldpxdot3locporttable_get_value (
   struct snmp_node_instance * cell_instance,
   void * value)
{
   s16_t value_len;
   int port = cell_instance->reference.s32;
   u32_t column =
      SNMP_TABLE_GET_COLUMN_FROM_OID (cell_instance->instance_oid.id);

   switch (column)
   {
   case 1:
   {
      /* lldpXdot3LocPortAutoNegSupported */
      s32_t * v = (s32_t *)value;
      pf_snmp_link_status_t link_status;

      pf_snmp_get_link_status (pnal_snmp.net, port, &link_status);
      value_len = sizeof (s32_t);
      *v = link_status.auto_neg_supported;
   }
   break;
   case 2:
   {
      /* lldpXdot3LocPortAutoNegEnabled */
      s32_t * v = (s32_t *)value;
      pf_snmp_link_status_t link_status;

      pf_snmp_get_link_status (pnal_snmp.net, port, &link_status);
      value_len = sizeof (s32_t);
      *v = link_status.auto_neg_enabled;
   }
   break;
   case 3:
   {
      /* lldpXdot3LocPortAutoNegAdvertisedCap */
      u8_t * v = (u8_t *)value;
      pf_snmp_link_status_t link_status;

      pf_snmp_get_link_status (pnal_snmp.net, port, &link_status);
      value_len = 2;
      memcpy (v, link_status.auto_neg_advertised_cap, 2);
   }
   break;
   case 4:
   {
      /* lldpXdot3LocPortOperMauType */
      s32_t * v = (s32_t *)value;
      pf_snmp_link_status_t link_status;

      pf_snmp_get_link_status (pnal_snmp.net, port, &link_status);
      value_len = sizeof (s32_t);
      *v = link_status.oper_mau_type;
   }
   break;
   default:
   {
      LOG_ERROR (
         PF_SNMP_LOG,
         "LLDP-EXT-DOT3-MIB(%d): Unknown table column: %" PRIu32 ".\n",
         __LINE__,
         column);
      value_len = 0;
   }
   break;
   }

   return value_len;
}

/* --- lldpXdot3RemoteData 1.0.8802.1.1.2.1.5.4623.1.3
 * ----------------------------------------------------- */

/**
 * Get cell in table lldpXdot3RemPortTable.
 *
 * Called when an SNMP Get request is received for this table.
 * If cell is found, the SNMP stack may call the corresponding get_value()
 * function below to retrieve the actual value contained in the cell.
 *
 * @param column           In:    Column index for the cell.
 * @param row_oid          In:    Row index (array) for the cell.
 * @param row_oid_len      In:    The number of elements in the row index array.
 * @param cell_instance    InOut: Cell instance (containing meta-data).
 * @return  SNMP_ERR_NOERROR if cell was found,
 *          SNMP_ERR_NOSUCHINSTANCE otherwise.
 */
static snmp_err_t lldpxdot3remporttable_get_instance (
   const u32_t * column,
   const u32_t * row_oid,
   u8_t row_oid_len,
   struct snmp_node_instance * cell_instance)
{
   int port = rowindex_match_with_remote_device (row_oid, row_oid_len);
   if (port == 0)
   {
      return SNMP_ERR_NOSUCHINSTANCE;
   }
   else
   {
      cell_instance->reference.s32 = port;
      return SNMP_ERR_NOERROR;
   }
}

/**
 * Get next cell in table lldpXdot3RemPortTable.
 *
 * Called when an SNMP GetNext request is received for this table.
 * If cell is found, the SNMP stack may call the corresponding get_value()
 * function below to retrieve the actual value contained in the cell.
 *
 * @param column           In:    Column index for the cell.
 * @param row_oid          InOut: Row index for the cell.
 * @param cell_instance    InOut: Cell instance (containing meta-data).
 * @return  SNMP_ERR_NOERROR if cell was found,
 *          SNMP_ERR_NOSUCHINSTANCE otherwise.
 */
static snmp_err_t lldpxdot3remporttable_get_next_instance (
   const u32_t * column,
   struct snmp_obj_id * row_oid,
   struct snmp_node_instance * cell_instance)
{
   int port = rowindex_update_with_next_remote_device (row_oid);
   if (port == 0)
   {
      return SNMP_ERR_NOSUCHINSTANCE;
   }
   else
   {
      cell_instance->reference.s32 = port;
      return SNMP_ERR_NOERROR;
   }
}

/**
 * Get value at cell in table lldpXdot3RemPortTable.
 *
 * Called when an SNMP Get or GetNext request is received for this table.
 * The cell was previously identified in a call to get_instance() or
 * get_next_instance().
 *
 * @param cell_instance    In:    Cell instance (containing meta-data).
 * @param value            Out:   Value to be returned in response.
 * @return  Size of returned value, in bytes.
 *          0 if error occurred.
 */
static s16_t lldpxdot3remporttable_get_value (
   struct snmp_node_instance * cell_instance,
   void * value)
{
   s16_t value_len;
   int port = cell_instance->reference.s32;
   u32_t column =
      SNMP_TABLE_GET_COLUMN_FROM_OID (cell_instance->instance_oid.id);

   switch (column)
   {
   case 1:
   {
      /* lldpXdot3RemPortAutoNegSupported */
      s32_t * v = (s32_t *)value;
      pf_snmp_link_status_t link_status;
      int error;

      error = pf_snmp_get_peer_link_status (pnal_snmp.net, port, &link_status);
      if (error)
      {
         value_len = 0;
      }
      else
      {
         value_len = sizeof (s32_t);
         *v = link_status.auto_neg_supported;
      }
   }
   break;
   case 2:
   {
      /* lldpXdot3RemPortAutoNegEnabled */
      s32_t * v = (s32_t *)value;
      pf_snmp_link_status_t link_status;
      int error;

      error = pf_snmp_get_peer_link_status (pnal_snmp.net, port, &link_status);
      if (error)
      {
         value_len = 0;
      }
      else
      {
         value_len = sizeof (s32_t);
         *v = link_status.auto_neg_enabled;
      }
   }
   break;
   case 3:
   {
      /* lldpXdot3RemPortAutoNegAdvertisedCap */
      u8_t * v = (u8_t *)value;
      pf_snmp_link_status_t link_status;
      int error;

      error = pf_snmp_get_peer_link_status (pnal_snmp.net, port, &link_status);
      if (error)
      {
         value_len = 0;
      }
      else
      {
         value_len = 2;
         memcpy (v, link_status.auto_neg_advertised_cap, 2);
      }
   }
   break;
   case 4:
   {
      /* lldpXdot3RemPortOperMauType */
      s32_t * v = (s32_t *)value;
      pf_snmp_link_status_t link_status;
      int error;

      error = pf_snmp_get_peer_link_status (pnal_snmp.net, port, &link_status);
      if (error)
      {
         value_len = 0;
      }
      else
      {
         value_len = sizeof (s32_t);
         *v = link_status.oper_mau_type;
      }
   }
   break;
   default:
   {
      LOG_ERROR (
         PF_SNMP_LOG,
         "LLDP-EXT-DOT3-MIB(%d): Unknown table column: %" PRIu32 ".\n",
         __LINE__,
         column);
      value_len = 0;
   }
   break;
   }

   return value_len;
}

/* --- lldpXdot3Objects 1.0.8802.1.1.2.1.5.4623.1
 * ----------------------------------------------------- */
/* --- lldpXdot3MIB  ----------------------------------------------------- */
#endif /* LWIP_SNMP */
